revoke delete on table "auth"."audit_log_entries" from "dashboard_user";

revoke insert on table "auth"."audit_log_entries" from "dashboard_user";

revoke references on table "auth"."audit_log_entries" from "dashboard_user";

revoke select on table "auth"."audit_log_entries" from "dashboard_user";

revoke trigger on table "auth"."audit_log_entries" from "dashboard_user";

revoke truncate on table "auth"."audit_log_entries" from "dashboard_user";

revoke update on table "auth"."audit_log_entries" from "dashboard_user";

revoke delete on table "auth"."audit_log_entries" from "postgres";

revoke insert on table "auth"."audit_log_entries" from "postgres";

revoke references on table "auth"."audit_log_entries" from "postgres";

revoke select on table "auth"."audit_log_entries" from "postgres";

revoke trigger on table "auth"."audit_log_entries" from "postgres";

revoke truncate on table "auth"."audit_log_entries" from "postgres";

revoke update on table "auth"."audit_log_entries" from "postgres";

revoke delete on table "auth"."flow_state" from "dashboard_user";

revoke insert on table "auth"."flow_state" from "dashboard_user";

revoke references on table "auth"."flow_state" from "dashboard_user";

revoke select on table "auth"."flow_state" from "dashboard_user";

revoke trigger on table "auth"."flow_state" from "dashboard_user";

revoke truncate on table "auth"."flow_state" from "dashboard_user";

revoke update on table "auth"."flow_state" from "dashboard_user";

revoke delete on table "auth"."flow_state" from "postgres";

revoke insert on table "auth"."flow_state" from "postgres";

revoke references on table "auth"."flow_state" from "postgres";

revoke select on table "auth"."flow_state" from "postgres";

revoke trigger on table "auth"."flow_state" from "postgres";

revoke truncate on table "auth"."flow_state" from "postgres";

revoke update on table "auth"."flow_state" from "postgres";

revoke delete on table "auth"."identities" from "dashboard_user";

revoke insert on table "auth"."identities" from "dashboard_user";

revoke references on table "auth"."identities" from "dashboard_user";

revoke select on table "auth"."identities" from "dashboard_user";

revoke trigger on table "auth"."identities" from "dashboard_user";

revoke truncate on table "auth"."identities" from "dashboard_user";

revoke update on table "auth"."identities" from "dashboard_user";

revoke delete on table "auth"."identities" from "postgres";

revoke insert on table "auth"."identities" from "postgres";

revoke references on table "auth"."identities" from "postgres";

revoke select on table "auth"."identities" from "postgres";

revoke trigger on table "auth"."identities" from "postgres";

revoke truncate on table "auth"."identities" from "postgres";

revoke update on table "auth"."identities" from "postgres";

revoke delete on table "auth"."instances" from "dashboard_user";

revoke insert on table "auth"."instances" from "dashboard_user";

revoke references on table "auth"."instances" from "dashboard_user";

revoke select on table "auth"."instances" from "dashboard_user";

revoke trigger on table "auth"."instances" from "dashboard_user";

revoke truncate on table "auth"."instances" from "dashboard_user";

revoke update on table "auth"."instances" from "dashboard_user";

revoke delete on table "auth"."instances" from "postgres";

revoke insert on table "auth"."instances" from "postgres";

revoke references on table "auth"."instances" from "postgres";

revoke select on table "auth"."instances" from "postgres";

revoke trigger on table "auth"."instances" from "postgres";

revoke truncate on table "auth"."instances" from "postgres";

revoke update on table "auth"."instances" from "postgres";

revoke delete on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke insert on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke references on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke select on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke trigger on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke truncate on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke update on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke delete on table "auth"."mfa_amr_claims" from "postgres";

revoke insert on table "auth"."mfa_amr_claims" from "postgres";

revoke references on table "auth"."mfa_amr_claims" from "postgres";

revoke select on table "auth"."mfa_amr_claims" from "postgres";

revoke trigger on table "auth"."mfa_amr_claims" from "postgres";

revoke truncate on table "auth"."mfa_amr_claims" from "postgres";

revoke update on table "auth"."mfa_amr_claims" from "postgres";

revoke delete on table "auth"."mfa_challenges" from "dashboard_user";

revoke insert on table "auth"."mfa_challenges" from "dashboard_user";

revoke references on table "auth"."mfa_challenges" from "dashboard_user";

revoke select on table "auth"."mfa_challenges" from "dashboard_user";

revoke trigger on table "auth"."mfa_challenges" from "dashboard_user";

revoke truncate on table "auth"."mfa_challenges" from "dashboard_user";

revoke update on table "auth"."mfa_challenges" from "dashboard_user";

revoke delete on table "auth"."mfa_challenges" from "postgres";

revoke insert on table "auth"."mfa_challenges" from "postgres";

revoke references on table "auth"."mfa_challenges" from "postgres";

revoke select on table "auth"."mfa_challenges" from "postgres";

revoke trigger on table "auth"."mfa_challenges" from "postgres";

revoke truncate on table "auth"."mfa_challenges" from "postgres";

revoke update on table "auth"."mfa_challenges" from "postgres";

revoke delete on table "auth"."mfa_factors" from "dashboard_user";

revoke insert on table "auth"."mfa_factors" from "dashboard_user";

revoke references on table "auth"."mfa_factors" from "dashboard_user";

revoke select on table "auth"."mfa_factors" from "dashboard_user";

revoke trigger on table "auth"."mfa_factors" from "dashboard_user";

revoke truncate on table "auth"."mfa_factors" from "dashboard_user";

revoke update on table "auth"."mfa_factors" from "dashboard_user";

revoke delete on table "auth"."mfa_factors" from "postgres";

revoke insert on table "auth"."mfa_factors" from "postgres";

revoke references on table "auth"."mfa_factors" from "postgres";

revoke select on table "auth"."mfa_factors" from "postgres";

revoke trigger on table "auth"."mfa_factors" from "postgres";

revoke truncate on table "auth"."mfa_factors" from "postgres";

revoke update on table "auth"."mfa_factors" from "postgres";

revoke delete on table "auth"."one_time_tokens" from "dashboard_user";

revoke insert on table "auth"."one_time_tokens" from "dashboard_user";

revoke references on table "auth"."one_time_tokens" from "dashboard_user";

revoke select on table "auth"."one_time_tokens" from "dashboard_user";

revoke trigger on table "auth"."one_time_tokens" from "dashboard_user";

revoke truncate on table "auth"."one_time_tokens" from "dashboard_user";

revoke update on table "auth"."one_time_tokens" from "dashboard_user";

revoke delete on table "auth"."one_time_tokens" from "postgres";

revoke insert on table "auth"."one_time_tokens" from "postgres";

revoke references on table "auth"."one_time_tokens" from "postgres";

revoke select on table "auth"."one_time_tokens" from "postgres";

revoke trigger on table "auth"."one_time_tokens" from "postgres";

revoke truncate on table "auth"."one_time_tokens" from "postgres";

revoke update on table "auth"."one_time_tokens" from "postgres";

revoke delete on table "auth"."refresh_tokens" from "dashboard_user";

revoke insert on table "auth"."refresh_tokens" from "dashboard_user";

revoke references on table "auth"."refresh_tokens" from "dashboard_user";

revoke select on table "auth"."refresh_tokens" from "dashboard_user";

revoke trigger on table "auth"."refresh_tokens" from "dashboard_user";

revoke truncate on table "auth"."refresh_tokens" from "dashboard_user";

revoke update on table "auth"."refresh_tokens" from "dashboard_user";

revoke delete on table "auth"."refresh_tokens" from "postgres";

revoke insert on table "auth"."refresh_tokens" from "postgres";

revoke references on table "auth"."refresh_tokens" from "postgres";

revoke select on table "auth"."refresh_tokens" from "postgres";

revoke trigger on table "auth"."refresh_tokens" from "postgres";

revoke truncate on table "auth"."refresh_tokens" from "postgres";

revoke update on table "auth"."refresh_tokens" from "postgres";

revoke delete on table "auth"."saml_providers" from "dashboard_user";

revoke insert on table "auth"."saml_providers" from "dashboard_user";

revoke references on table "auth"."saml_providers" from "dashboard_user";

revoke select on table "auth"."saml_providers" from "dashboard_user";

revoke trigger on table "auth"."saml_providers" from "dashboard_user";

revoke truncate on table "auth"."saml_providers" from "dashboard_user";

revoke update on table "auth"."saml_providers" from "dashboard_user";

revoke delete on table "auth"."saml_providers" from "postgres";

revoke insert on table "auth"."saml_providers" from "postgres";

revoke references on table "auth"."saml_providers" from "postgres";

revoke select on table "auth"."saml_providers" from "postgres";

revoke trigger on table "auth"."saml_providers" from "postgres";

revoke truncate on table "auth"."saml_providers" from "postgres";

revoke update on table "auth"."saml_providers" from "postgres";

revoke delete on table "auth"."saml_relay_states" from "dashboard_user";

revoke insert on table "auth"."saml_relay_states" from "dashboard_user";

revoke references on table "auth"."saml_relay_states" from "dashboard_user";

revoke select on table "auth"."saml_relay_states" from "dashboard_user";

revoke trigger on table "auth"."saml_relay_states" from "dashboard_user";

revoke truncate on table "auth"."saml_relay_states" from "dashboard_user";

revoke update on table "auth"."saml_relay_states" from "dashboard_user";

revoke delete on table "auth"."saml_relay_states" from "postgres";

revoke insert on table "auth"."saml_relay_states" from "postgres";

revoke references on table "auth"."saml_relay_states" from "postgres";

revoke select on table "auth"."saml_relay_states" from "postgres";

revoke trigger on table "auth"."saml_relay_states" from "postgres";

revoke truncate on table "auth"."saml_relay_states" from "postgres";

revoke update on table "auth"."saml_relay_states" from "postgres";

revoke delete on table "auth"."schema_migrations" from "dashboard_user";

revoke insert on table "auth"."schema_migrations" from "dashboard_user";

revoke references on table "auth"."schema_migrations" from "dashboard_user";

revoke select on table "auth"."schema_migrations" from "dashboard_user";

revoke trigger on table "auth"."schema_migrations" from "dashboard_user";

revoke truncate on table "auth"."schema_migrations" from "dashboard_user";

revoke update on table "auth"."schema_migrations" from "dashboard_user";

revoke delete on table "auth"."schema_migrations" from "postgres";

revoke insert on table "auth"."schema_migrations" from "postgres";

revoke references on table "auth"."schema_migrations" from "postgres";

revoke select on table "auth"."schema_migrations" from "postgres";

revoke trigger on table "auth"."schema_migrations" from "postgres";

revoke truncate on table "auth"."schema_migrations" from "postgres";

revoke update on table "auth"."schema_migrations" from "postgres";

revoke delete on table "auth"."sessions" from "dashboard_user";

revoke insert on table "auth"."sessions" from "dashboard_user";

revoke references on table "auth"."sessions" from "dashboard_user";

revoke select on table "auth"."sessions" from "dashboard_user";

revoke trigger on table "auth"."sessions" from "dashboard_user";

revoke truncate on table "auth"."sessions" from "dashboard_user";

revoke update on table "auth"."sessions" from "dashboard_user";

revoke delete on table "auth"."sessions" from "postgres";

revoke insert on table "auth"."sessions" from "postgres";

revoke references on table "auth"."sessions" from "postgres";

revoke select on table "auth"."sessions" from "postgres";

revoke trigger on table "auth"."sessions" from "postgres";

revoke truncate on table "auth"."sessions" from "postgres";

revoke update on table "auth"."sessions" from "postgres";

revoke delete on table "auth"."sso_domains" from "dashboard_user";

revoke insert on table "auth"."sso_domains" from "dashboard_user";

revoke references on table "auth"."sso_domains" from "dashboard_user";

revoke select on table "auth"."sso_domains" from "dashboard_user";

revoke trigger on table "auth"."sso_domains" from "dashboard_user";

revoke truncate on table "auth"."sso_domains" from "dashboard_user";

revoke update on table "auth"."sso_domains" from "dashboard_user";

revoke delete on table "auth"."sso_domains" from "postgres";

revoke insert on table "auth"."sso_domains" from "postgres";

revoke references on table "auth"."sso_domains" from "postgres";

revoke select on table "auth"."sso_domains" from "postgres";

revoke trigger on table "auth"."sso_domains" from "postgres";

revoke truncate on table "auth"."sso_domains" from "postgres";

revoke update on table "auth"."sso_domains" from "postgres";

revoke delete on table "auth"."sso_providers" from "dashboard_user";

revoke insert on table "auth"."sso_providers" from "dashboard_user";

revoke references on table "auth"."sso_providers" from "dashboard_user";

revoke select on table "auth"."sso_providers" from "dashboard_user";

revoke trigger on table "auth"."sso_providers" from "dashboard_user";

revoke truncate on table "auth"."sso_providers" from "dashboard_user";

revoke update on table "auth"."sso_providers" from "dashboard_user";

revoke delete on table "auth"."sso_providers" from "postgres";

revoke insert on table "auth"."sso_providers" from "postgres";

revoke references on table "auth"."sso_providers" from "postgres";

revoke select on table "auth"."sso_providers" from "postgres";

revoke trigger on table "auth"."sso_providers" from "postgres";

revoke truncate on table "auth"."sso_providers" from "postgres";

revoke update on table "auth"."sso_providers" from "postgres";

revoke delete on table "auth"."users" from "dashboard_user";

revoke insert on table "auth"."users" from "dashboard_user";

revoke references on table "auth"."users" from "dashboard_user";

revoke select on table "auth"."users" from "dashboard_user";

revoke trigger on table "auth"."users" from "dashboard_user";

revoke truncate on table "auth"."users" from "dashboard_user";

revoke update on table "auth"."users" from "dashboard_user";

revoke delete on table "auth"."users" from "postgres";

revoke insert on table "auth"."users" from "postgres";

revoke references on table "auth"."users" from "postgres";

revoke select on table "auth"."users" from "postgres";

revoke trigger on table "auth"."users" from "postgres";

revoke truncate on table "auth"."users" from "postgres";

revoke update on table "auth"."users" from "postgres";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION auth.custom_access_token2(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  uid    uuid;
  roles  jsonb;
begin
  -- evt is the base-claims JSON; skip anon sessions
  if not evt ? 'sub' then
    return evt;
  end if;

  uid := (evt ->> 'sub')::uuid;

  /* fetch active roles (index on user_id,is_active) */
  select jsonb_agg(jsonb_build_object(
           'role_id',        r.role_id,
           'role',           ro.role,
           'organization_id',r.organization_id,
           'organization',   org.name))
    into roles
  from   user_organization_roles r
  join   roles            ro  on ro.id  = r.role_id
  join   organizations    org on org.id = r.organization_id
  where  r.user_id = uid
    and  r.is_active;

  roles := coalesce(roles, '[]'::jsonb);

  /* merge roles into the existing claim set */
  return evt || jsonb_build_object(
           'app_metadata', jsonb_build_object(
             'roles',       roles,
             'role_count',  jsonb_array_length(roles)
           )
         );
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.new_custom_access_token(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  uid          uuid;
  roles        jsonb;
  meta         jsonb;
  primary_role text;
begin
  /* Skip anon / service-role sessions ----------------------------------------- */
  if not evt ? 'sub' then
    return evt;
  end if;

  uid := (evt ->> 'sub')::uuid;

  /* Build array of active role assignments ----------------------------------- */
  select jsonb_agg(
           jsonb_build_object(
             'id',                       r.id,
             'assigned_at',              r.assigned_at,
             'assignment_updated_at',    r.assignment_updated_at,
             'is_active',                r.is_active,
             'organization_id',          r.organization_id,
             'organization_is_active',   org.is_active,
             'organization_name',        org.name,
             'role_id',                  ro.id,
             'role_name',                ro.role
           )
         )
    into roles
  from   user_organization_roles r
  join   roles            ro  on ro.id  = r.role_id
  join   organizations    org on org.id = r.organization_id
  where  r.user_id = uid
    and  r.is_active;

  roles := coalesce(roles, '[]'::jsonb);

  /* Choose a “primary” role for quick front-end checks ----------------------- */
  select coalesce(
           (select 'superVera' from jsonb_array_elements(roles) e
             where e->>'role_name' = 'superVera' limit 1),
           (select 'admin'     from jsonb_array_elements(roles) e
             where e->>'role_name' = 'admin' limit 1),
           (select e->>'role_name' from jsonb_array_elements(roles) e limit 1)
         )
    into primary_role;

  /* Extend—don’t overwrite—existing app_metadata ----------------------------- */
  meta := coalesce(evt -> 'app_metadata', '{}'::jsonb);

  meta := meta
          || jsonb_build_object(
               'roles',         roles,
               'role_count',    jsonb_array_length(roles),
               'role',          primary_role,
               'last_role_sync', to_char(
                                   now() at time zone 'UTC',
                                   'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
                                 )
             );

  /* Return the merged claim set --------------------------------------------- */
  return evt || jsonb_build_object('app_metadata', meta);
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.new_custom_access_token_v2(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  uid          uuid;
  roles        jsonb;
  meta         jsonb;
  primary_role text;
  full_evt     jsonb;
  new_claims   jsonb;
begin
  -- No longer skipping anon/service-role: always execute

  uid := (evt ->> 'sub')::uuid;

  select coalesce(jsonb_agg(
    jsonb_build_object(
      'id',                       r.id,
      'assigned_at',              r.assigned_at,
      'assignment_updated_at',    r.assignment_updated_at,
      'is_active',                r.is_active,
      'organization_id',          r.organization_id,
      'organization_is_active',   org.is_active,
      'organization_name',        org.name,
      'role_id',                  ro.id,
      'role_name',                ro.role,
      'user_email',               up.email,
      'user_full_name',           up.full_name,
      'user_id',                  up.user_id,
      'user_phone',               up.phone,
      'user_visible_name',        up.visible_name
    )
  ), '[]'::jsonb)
    into roles
  from user_organization_roles r
  join roles ro   on ro.id = r.role_id
  join organizations org on org.id = r.organization_id
  left join user_profiles up on up.user_id = r.user_id
  where (evt ? 'sub' and r.user_id = uid and r.is_active) OR NOT (evt ? 'sub');

  select coalesce(
    (select 'superVera' from jsonb_array_elements(roles) e where e->>'role_name' = 'superVera' limit 1),
    (select 'admin' from jsonb_array_elements(roles) e where e->>'role_name' = 'admin' limit 1),
    (select e->>'role_name' from jsonb_array_elements(roles) e limit 1)
  ) into primary_role;

  meta := coalesce(evt -> 'app_metadata', '{}'::jsonb)
          || jsonb_build_object(
               'roles',         roles,
               'role_count',    jsonb_array_length(roles),
               'role',          primary_role,
               'last_role_sync', to_char(now() at time zone 'UTC','YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')
             );

  full_evt := evt || jsonb_build_object('app_metadata', meta);
  new_claims := full_evt -> 'app_metadata';
  return jsonb_build_object('claims', new_claims);
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.new_custom_access_token_v3(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  uid          uuid;
  roles        jsonb;
  meta         jsonb;
  primary_role text;
begin
  -- Skip anon / service-role sessions
  if not evt ? 'sub' then
    return evt;
  end if;

  uid := (evt ->> 'sub')::uuid;

  -- Build array of active role assignments using the view
  select coalesce(jsonb_agg(row_to_json(v)), '[]'::jsonb)
    into roles
  from view_user_roles_with_details v
  where v.user_id = uid
    and v.is_active;

  -- Determine primary role
  select coalesce(
    (select 'superVera'         from jsonb_array_elements(roles) e where e->>'role_name' = 'superVera' limit 1),
    (select 'admin'             from jsonb_array_elements(roles) e where e->>'role_name' = 'admin' limit 1),
    (select e->>'role_name'     from jsonb_array_elements(roles) e                             limit 1)
  )
  into primary_role;

  -- Prepare merged app_metadata
  meta := coalesce(evt -> 'app_metadata', '{}'::jsonb)
          || jsonb_build_object(
               'roles',          roles,
               'role_count',     jsonb_array_length(roles),
               'role',           primary_role,
               'last_role_sync', to_char(now() at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')
             );

  -- Return updated claims payload
  return jsonb_build_object('claims', meta);
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.new_custom_access_token_v4(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  uid          uuid;
  roles        jsonb := '[]'::jsonb;
  primary_role text := 'user';
  new_meta     jsonb;
  claims       jsonb;
begin
  -- Parse user ID
  uid := (evt ->> 'sub')::uuid;

  -- Fetch roles from the view
  select coalesce(jsonb_agg(
    jsonb_build_object(
      'id', id,
      'role_name', role_name,
      'organization_id', organization_id,
      'organization_name', organization_name,
      'organization_is_active', organization_is_active,
      'assigned_at', assigned_at,
      'assignment_updated_at', assignment_updated_at
    )
  ), '[]'::jsonb)
  into roles
  from public.view_user_roles_with_details
  where user_id = uid and is_active;

  -- Logging: how many roles found
  raise notice 'User % has % roles', uid, jsonb_array_length(roles);

  -- Pick primary role (override as needed)
  select coalesce(
    (select 'superVera' from jsonb_array_elements(roles) e where e->>'role_name' = 'superVera' limit 1),
    (select 'admin' from jsonb_array_elements(roles) e where e->>'role_name' = 'admin' limit 1),
    (select e->>'role_name' from jsonb_array_elements(roles) e limit 1)
  )
  into primary_role;

  -- Build new app_metadata
  new_meta := jsonb_build_object(
    'roles', roles,
    'role_count', jsonb_array_length(roles),
    'role', primary_role,
    'last_role_sync', to_char(now() at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')
  );

  -- Full override of app_metadata in claims
  claims := evt || jsonb_build_object('app_metadata', new_meta);

  -- Return full claims object
  return jsonb_build_object('claims', claims);
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.test_hook(evt jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  raise notice 'HOOK CALLED: %', evt;
  return evt;
end;
$function$
;

CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
;

CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
;

CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
;

CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
;

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();

CREATE TRIGGER user_after_insert AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION trg_user_after_insert();


revoke delete on table "storage"."buckets" from "anon";

revoke insert on table "storage"."buckets" from "anon";

revoke references on table "storage"."buckets" from "anon";

revoke select on table "storage"."buckets" from "anon";

revoke trigger on table "storage"."buckets" from "anon";

revoke truncate on table "storage"."buckets" from "anon";

revoke update on table "storage"."buckets" from "anon";

revoke delete on table "storage"."buckets" from "authenticated";

revoke insert on table "storage"."buckets" from "authenticated";

revoke references on table "storage"."buckets" from "authenticated";

revoke select on table "storage"."buckets" from "authenticated";

revoke trigger on table "storage"."buckets" from "authenticated";

revoke truncate on table "storage"."buckets" from "authenticated";

revoke update on table "storage"."buckets" from "authenticated";

revoke delete on table "storage"."buckets" from "postgres";

revoke insert on table "storage"."buckets" from "postgres";

revoke references on table "storage"."buckets" from "postgres";

revoke select on table "storage"."buckets" from "postgres";

revoke trigger on table "storage"."buckets" from "postgres";

revoke truncate on table "storage"."buckets" from "postgres";

revoke update on table "storage"."buckets" from "postgres";

revoke delete on table "storage"."buckets" from "service_role";

revoke insert on table "storage"."buckets" from "service_role";

revoke references on table "storage"."buckets" from "service_role";

revoke select on table "storage"."buckets" from "service_role";

revoke trigger on table "storage"."buckets" from "service_role";

revoke truncate on table "storage"."buckets" from "service_role";

revoke update on table "storage"."buckets" from "service_role";

revoke delete on table "storage"."migrations" from "anon";

revoke insert on table "storage"."migrations" from "anon";

revoke references on table "storage"."migrations" from "anon";

revoke select on table "storage"."migrations" from "anon";

revoke trigger on table "storage"."migrations" from "anon";

revoke truncate on table "storage"."migrations" from "anon";

revoke update on table "storage"."migrations" from "anon";

revoke delete on table "storage"."migrations" from "authenticated";

revoke insert on table "storage"."migrations" from "authenticated";

revoke references on table "storage"."migrations" from "authenticated";

revoke select on table "storage"."migrations" from "authenticated";

revoke trigger on table "storage"."migrations" from "authenticated";

revoke truncate on table "storage"."migrations" from "authenticated";

revoke update on table "storage"."migrations" from "authenticated";

revoke delete on table "storage"."migrations" from "postgres";

revoke insert on table "storage"."migrations" from "postgres";

revoke references on table "storage"."migrations" from "postgres";

revoke select on table "storage"."migrations" from "postgres";

revoke trigger on table "storage"."migrations" from "postgres";

revoke truncate on table "storage"."migrations" from "postgres";

revoke update on table "storage"."migrations" from "postgres";

revoke delete on table "storage"."migrations" from "service_role";

revoke insert on table "storage"."migrations" from "service_role";

revoke references on table "storage"."migrations" from "service_role";

revoke select on table "storage"."migrations" from "service_role";

revoke trigger on table "storage"."migrations" from "service_role";

revoke truncate on table "storage"."migrations" from "service_role";

revoke update on table "storage"."migrations" from "service_role";

revoke delete on table "storage"."objects" from "anon";

revoke insert on table "storage"."objects" from "anon";

revoke references on table "storage"."objects" from "anon";

revoke select on table "storage"."objects" from "anon";

revoke trigger on table "storage"."objects" from "anon";

revoke truncate on table "storage"."objects" from "anon";

revoke update on table "storage"."objects" from "anon";

revoke delete on table "storage"."objects" from "authenticated";

revoke insert on table "storage"."objects" from "authenticated";

revoke references on table "storage"."objects" from "authenticated";

revoke select on table "storage"."objects" from "authenticated";

revoke trigger on table "storage"."objects" from "authenticated";

revoke truncate on table "storage"."objects" from "authenticated";

revoke update on table "storage"."objects" from "authenticated";

revoke delete on table "storage"."objects" from "postgres";

revoke insert on table "storage"."objects" from "postgres";

revoke references on table "storage"."objects" from "postgres";

revoke select on table "storage"."objects" from "postgres";

revoke trigger on table "storage"."objects" from "postgres";

revoke truncate on table "storage"."objects" from "postgres";

revoke update on table "storage"."objects" from "postgres";

revoke delete on table "storage"."objects" from "service_role";

revoke insert on table "storage"."objects" from "service_role";

revoke references on table "storage"."objects" from "service_role";

revoke select on table "storage"."objects" from "service_role";

revoke trigger on table "storage"."objects" from "service_role";

revoke truncate on table "storage"."objects" from "service_role";

revoke update on table "storage"."objects" from "service_role";

revoke select on table "storage"."s3_multipart_uploads" from "anon";

revoke select on table "storage"."s3_multipart_uploads" from "authenticated";

revoke delete on table "storage"."s3_multipart_uploads" from "service_role";

revoke insert on table "storage"."s3_multipart_uploads" from "service_role";

revoke references on table "storage"."s3_multipart_uploads" from "service_role";

revoke select on table "storage"."s3_multipart_uploads" from "service_role";

revoke trigger on table "storage"."s3_multipart_uploads" from "service_role";

revoke truncate on table "storage"."s3_multipart_uploads" from "service_role";

revoke update on table "storage"."s3_multipart_uploads" from "service_role";

revoke select on table "storage"."s3_multipart_uploads_parts" from "anon";

revoke select on table "storage"."s3_multipart_uploads_parts" from "authenticated";

revoke delete on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke insert on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke references on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke select on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke trigger on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke truncate on table "storage"."s3_multipart_uploads_parts" from "service_role";

revoke update on table "storage"."s3_multipart_uploads_parts" from "service_role";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
;

CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
_filename text;
BEGIN
	select string_to_array(name, '/') into _parts;
	select _parts[array_length(_parts,1)] into _filename;
	-- @todo return the last part instead of 2
	return reverse(split_part(reverse(_filename), '.', 1));
END
$function$
;

CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[1:array_length(_parts,1)-1];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::int) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$function$
;

CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  v_order_by text;
  v_sort_order text;
begin
  case
    when sortcolumn = 'name' then
      v_order_by = 'name';
    when sortcolumn = 'updated_at' then
      v_order_by = 'updated_at';
    when sortcolumn = 'created_at' then
      v_order_by = 'created_at';
    when sortcolumn = 'last_accessed_at' then
      v_order_by = 'last_accessed_at';
    else
      v_order_by = 'name';
  end case;

  case
    when sortorder = 'asc' then
      v_sort_order = 'asc';
    when sortorder = 'desc' then
      v_sort_order = 'desc';
    else
      v_sort_order = 'asc';
  end case;

  v_order_by = v_order_by || ' ' || v_sort_order;

  return query execute
    'with folders as (
       select path_tokens[$1] as folder
       from storage.objects
         where objects.name ilike $2 || $3 || ''%''
           and bucket_id = $4
           and array_length(objects.path_tokens, 1) <> $1
       group by folder
       order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
;

CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
;

create policy "Admin Delete Item Images"
on "storage"."objects"
as permissive
for delete
to public
using (((bucket_id = 'item-images'::text) AND (auth.role() = 'authenticated'::text)));


create policy "Admin Insert Item Images"
on "storage"."objects"
as permissive
for insert
to public
with check (((bucket_id = 'item-images'::text) AND (auth.role() = 'authenticated'::text)));


create policy "Public Access to Item Images"
on "storage"."objects"
as permissive
for select
to public
using ((bucket_id = 'item-images'::text));


create policy "Public Read Access"
on "storage"."objects"
as permissive
for select
to public
using ((bucket_id = 'item-images'::text));



