name: Deploy Supabase Migrations (Drift-aware)

on:
  # Run on PRs to develop so we can test safely (no deploy in PRs)
  pull_request:
    branches: [develop]
    paths:
      - 'supabase/migrations/**'
  # Auto-deploy only on merge/pushes to develop (after PR merge)
  push:
    branches: [develop]
    paths:
      - 'supabase/migrations/**'
  # Allow manual runs with toggles
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Actually deploy migrations (false = dry-run/drift only)'
        required: true
        default: 'false'
        type: choice
        options: ['false','true']

concurrency:
  group: supabase-migrations-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write       # push branches / commit drift file
  pull-requests: write  # open or comment on PRs
  issues: write         # comment if needed

env:
  # Working with supabase/ folder directly
  SCHEMAS: public
  # Using production secrets
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  PRODUCTION_PROJECT_ID: ${{ secrets.PRODUCTION_PROJECT_ID }}
  PRODUCTION_DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}

jobs:
  validate-and-deploy:
    name: Validate (and optionally deploy)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set production environment
        id: select
        run: |
          set -Eeuo pipefail
          echo "target=production" >> $GITHUB_OUTPUT
          echo "project_ref=${PRODUCTION_PROJECT_ID}" >> $GITHUB_OUTPUT
          echo "db_password=${PRODUCTION_DB_PASSWORD}" >> $GITHUB_OUTPUT

      - name: Verify required secrets
        run: |
          set -Eeuo pipefail
          [[ -n "${SUPABASE_ACCESS_TOKEN}" ]] || { echo "‚ùå SUPABASE_ACCESS_TOKEN missing"; exit 1; }
          [[ -n "${PRODUCTION_PROJECT_ID}" && -n "${PRODUCTION_DB_PASSWORD}" ]] || { echo "‚ùå PRODUCTION_* secrets missing"; exit 1; }
          echo "‚úÖ Secrets OK for production"

      - name: Install Supabase CLI (official action)
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Authenticate & link project
        run: |
          set -Eeuo pipefail
          supabase --version
          supabase login --token "$SUPABASE_ACCESS_TOKEN"
          supabase link --project-ref "${{ steps.select.outputs.project_ref }}" --password "${{ steps.select.outputs.db_password }}"

      - name: Sync missing remote migrations
        run: |
          set -Eeuo pipefail
          echo "üìä Migration status before sync:"
          supabase migrations list
          
          echo "üìä Migration status after sync:"
          supabase migrations list
          
          # Check if any new migration files were pulled
          NEW_MIGRATIONS=$(git status --porcelain supabase/migrations/ | grep "^??" | wc -l || echo "0")
          if [[ "$NEW_MIGRATIONS" -gt 0 ]]; then
            echo "‚úÖ Found $NEW_MIGRATIONS new migrations, committing them..."
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add supabase/migrations/
            git commit -m "feat: sync remote migrations from production" || true
          else
            echo "‚ÑπÔ∏è No new migrations to sync"
          fi

      - name: Check for migration changes in this commit range
        id: changes
        run: |
          set -Eeuo pipefail
          if [[ "${{ github.event_name }}" == "push" ]]; then
            PREV="HEAD~1"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PREV="origin/${{ github.base_ref }}"
          else
            # workflow_dispatch or other events: fall back to previous commit
            PREV="HEAD~1"
          fi
          echo "Diffing migrations between $PREV and HEAD..."
          CHANGED=$(git diff --name-only "$PREV" HEAD -- "supabase/migrations" || true)
          if [[ -z "$CHANGED" ]]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No migration file changes in this run"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "changed<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED"
          fi

      - name: Drift check against remote (no changes applied)
        id: drift
        run: |
          set -Eeuo pipefail
          # Debug: Show migrations folder contents before
          echo "üìÅ Migrations folder before drift check:"
          ls -la supabase/migrations/ || echo "migrations folder not found"
          
          supabase db start 
          supabase migrations list

          # Reset database to ensure shadow database is synced with migrations (like local setup)
          echo "üîÑ Resetting database to sync shadow database with migrations..."
          supabase db reset || true
          
          # Use simple filename like local setup to avoid path complexity
          echo "üîß Running: supabase db diff --linked --schema $SCHEMAS -f \"latest_diff\""
          supabase db diff --linked --schema $SCHEMAS -f "latest_diff" || true

          supabase db diff --linked --schema $SCHEMAS -f "latest_diff_remote" || true

          # Create a new file for local diff
          echo "üîß Running: supabase db diff --schema $SCHEMAS -f \"latest_diff_local\""
          supabase db diff --schema $SCHEMAS -f "latest_diff_local" || true

          # Debug: Show current directory after to see what was created
          echo "üìÅ Current directory after drift check:"
          ls -la . | head -10
          
          # Look for any files created matching latest_diff pattern in migrations folder
          DRIFT_FILES=$(find supabase/migrations/ -name "*latest_diff*" -type f 2>/dev/null || true)
          
          if [[ -n "$DRIFT_FILES" ]]; then
            # Find the newest file (in case multiple exist)
            LATEST_DRIFT=$(echo "$DRIFT_FILES" | head -n 1)
            echo "üîç Found drift file: $LATEST_DRIFT"
            
            # Check if it has content
            if [[ -s "$LATEST_DRIFT" ]]; then
              echo "‚úÖ Drift file already in correct location: $LATEST_DRIFT"
              echo "üìÑ Drift file size: $(wc -c < "$LATEST_DRIFT") bytes"
              echo "has_drift=true" >> $GITHUB_OUTPUT
              echo "drift_file=$LATEST_DRIFT" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Drift detected; file at $LATEST_DRIFT"
            else
              echo "‚ùå Drift file exists but is empty"
              rm -f "$LATEST_DRIFT" # Clean up empty file
              echo "has_drift=false" >> $GITHUB_OUTPUT
              echo "‚úÖ No schema drift detected"
            fi
          else
            echo "‚ùå No drift files found in migrations folder"
            echo "has_drift=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No schema drift detected"
          fi
          
          # Debug: Show migrations folder after processing
          echo "üìÅ Migrations folder after processing:"
          ls -la supabase/migrations/ || echo "migrations folder not found"
        shell: bash

      - name: Show drift (first 200 lines)
        if: steps.drift.outputs.has_drift == 'true'
        run: |
          echo "--- BEGIN DRIFT PREVIEW ---"
          sed -n '1,200p' "${{ steps.drift.outputs.drift_file }}" || true
          echo "--- END DRIFT PREVIEW ---"

      - name: Create a drift PR (if any)
        if: steps.drift.outputs.has_drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BRANCH="drift/$(date +%Y%m%d%H%M%S)"
          git checkout -b "$BRANCH"
          git add "${{ steps.drift.outputs.drift_file }}"
          git commit -m "chore(db): capture manual changes (drift)"
          git push -u origin "$BRANCH"
          
          # Debug: Check gh CLI status and create PR with better error handling
          echo "üîç Checking gh CLI authentication..."
          gh auth status || echo "Warning: gh auth issue detected"
          
          echo "üîß Creating PR from branch $BRANCH to develop..."
          if gh pr create --title "DB Drift: capture manual changes" \
            --body "Automatic drift detection created this PR. Review and merge to reconcile schema." \
            --base develop --head "$BRANCH" --repo "${{ github.repository }}"; then
            echo "‚úÖ PR created successfully"
          else
            echo "‚ùå PR creation failed. Attempting with different approach..."
            # Fallback: try without explicit repo
            gh pr create --title "DB Drift: capture manual changes" \
              --body "Automatic drift detection created this PR. Review and merge to reconcile schema." \
              --base develop --head "$BRANCH" || echo "‚ùå PR creation failed completely"
          fi

      - name: Decide whether to deploy
        id: deploy_gate
        run: |
          set -Eeuo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è PR context: validation only (no deploy)"
            exit 0
          fi
          if [[ "${{ steps.drift.outputs.has_drift }}" == "true" ]]; then
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Blocking deploy due to detected drift. A PR was/will be opened."
            exit 0
          fi
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "deploy=${{ inputs.deploy }}" >> $GITHUB_OUTPUT
          else
            # push to develop after merge: deploy
            echo "deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Show summary
        run: |
          echo "Target: ${{ steps.select.outputs.target }}"
          echo "Migrations changed: ${{ steps.changes.outputs.has_changes }}"
          echo "Drift: ${{ steps.drift.outputs.has_drift }}"
          echo "Schemas: $SCHEMAS"

      - name: Deploy migrations
        if: steps.deploy_gate.outputs.deploy == 'true' && steps.changes.outputs.has_changes == 'true'
        run: |
          set -Eeuo pipefail
          cd supabase && supabase db push
          cd supabase && supabase migration list

      - name: Skip deploy (explain why)
        if: steps.deploy_gate.outputs.deploy != 'true'
        run: |
          echo "‚è≠Ô∏è Skipping deployment. See logs above for reason (PR context, manual dry-run, or drift)."
